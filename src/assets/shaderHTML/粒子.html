<!DOCTYPE html>


<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
        <script src="https://unpkg.com/kokomi.js@1.9.78/build/kokomi.umd.js"></script>
        <script src="https://unpkg.com/three@0.154.0/build/three.min.js"></script>

    </head>
    <body>
        
        <div id="sketch"></div>
        <script>
            class Sketch extends kokomi.Base {
              create() {
                this.camera.position.set(0, 0, 5);
                new kokomi.OrbitControls(this);
                const geometry = new THREE.SphereGeometry(2, 64, 64);
                // const material = new THREE.MeshBasicMaterial({
                //   color: "#ffffff",
                // });
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        uPixelRatio: {
                          value: this.renderer.getPixelRatio(),
                        },
                        },
                    transparent: true,
                    //这两个设置项是例子系统的一般做法
                    blending: THREE.AdditiveBlending,//材质混合模式
                    depthWrite: false,//关闭深度写入
                      vertexShader: /* glsl */ `
                      varying vec2 vUv;
                      uniform float uPixelRatio;
                      //注入进来之后在两个着色器上都要声明一下
                      uniform float iTime;
                      uniform vec3 iResolution;
                      uniform vec4 iMouse;

                        vec3 distort(vec3 p){

                            // p.x+=sin(p.y*10.+iTime)*.25;
                            return p;
                        }

                      void main(){
                        vec3 p=position;
                        p=distort(p);
                        gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);//三维坐标下的三维坐标经过MVP矩阵变换转换为二维下的gl_Position
                        gl_PointSize=uPixelRatio*50.;
                        vec4 mvPosition=modelViewMatrix*vec4(p,1.);
                        gl_PointSize*=(1./-mvPosition.z);

                        vUv=uv;
                       
                    }

                      `,
                      fragmentShader: /* glsl */ `
                      varying vec2 vUv;
                      //注入进来之后在两个着色器上都要声明一下
                      uniform float iTime;
                      uniform vec3 iResolution;
                      uniform vec4 iMouse;
                      void main(){
                        vec2 uv=gl_PointCoord;
                        uv=(uv-.5)*2.;

                        float d=length(uv);
                        float c=.05/d;
                        c=pow(c,2.);
                        gl_FragColor=vec4(vec3(1.),c);
                    }

                      `,
                });

                const points = new THREE.Points(geometry, material);
                this.scene.add(points);
                //实例化一个UniformInjector 然后把uj里面的shadertoy里面的uniform变量合并到material的uniforms里面
                const uj = new kokomi.UniformInjector(this);
                material.uniforms = {
                    ...material.uniforms,
                    ...uj.shadertoyUniforms,
                };
                
                //在每一次执行更新的时候执行注入 这样就可以调用shadertoy里面的那些uniforms变量
                    this.update(() => {
                    uj.injectShadertoyUniforms(material.uniforms);
                });

              }
            }
          
            const sketch = new Sketch("#sketch");
            sketch.create();
          </script>
          
    </body>
    <style>
        body {
          margin: 0;
          background: black;
        }
      </style>
      
</html>